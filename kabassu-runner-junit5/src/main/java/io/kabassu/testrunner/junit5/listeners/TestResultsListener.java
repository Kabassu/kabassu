/*
 * Copyright (C) 2018 Kabassu
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.kabassu.testrunner.junit5.listeners;

import static java.util.stream.Stream.concat;

import io.kabassu.testrunner.junit5.summary.TestsExecutionSummary;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;
import java.util.stream.Stream;
import org.junit.platform.commons.util.PreconditionViolationException;
import org.junit.platform.engine.TestExecutionResult;
import org.junit.platform.launcher.TestExecutionListener;
import org.junit.platform.launcher.TestIdentifier;
import org.junit.platform.launcher.TestPlan;
import org.junit.platform.launcher.listeners.TestExecutionSummary;

public class TestResultsListener implements TestExecutionListener {

  private static final Logger LOGGER = LoggerFactory.getLogger(TestResultsListener.class);

  private TestPlan testPlan;

  private TestsExecutionSummary summary;

  /**
   * Get the summary generated by this listener.
   */
  public TestExecutionSummary getSummary() {
    return this.summary;
  }

  @Override
  public void testPlanExecutionStarted(TestPlan testPlan) {
    this.testPlan = testPlan;
    this.summary = new TestsExecutionSummary(testPlan);
  }

  @Override
  public void testPlanExecutionFinished(TestPlan testPlan) {
    this.summary.setTimeFinished(System.currentTimeMillis());
  }

  @Override
  public void dynamicTestRegistered(TestIdentifier testIdentifier) {
    if (testIdentifier.isContainer()) {
      this.summary.incrementContainersFound();
    }
    if (testIdentifier.isTest()) {
      this.summary.incrementTestsFound();
    }
  }

  @Override
  public void executionSkipped(TestIdentifier testIdentifier, String reason) {
    // @formatter:off
		long skippedContainers = concat(Stream.of(testIdentifier), testPlan.getDescendants(testIdentifier).stream())
				.filter(TestIdentifier::isContainer)
				.count();
		long skippedTests = concat(Stream.of(testIdentifier), testPlan.getDescendants(testIdentifier).stream())
				.filter(TestIdentifier::isTest)
				.count();
		// @formatter:on
    this.summary.addContainersSkipped(skippedContainers);
    this.summary.addTestsSkipped(skippedTests);
  }

  @Override
  public void executionStarted(TestIdentifier testIdentifier) {
    if (testIdentifier.isContainer()) {
      LOGGER.info(
          "Container: " + testIdentifier.getDisplayName() + " id: " + testIdentifier.getUniqueId()
              + " parent id: " + testIdentifier.getParentId());
      this.summary.incrementContainersStarted();
    }
    if (testIdentifier.isTest()) {
      LOGGER.info(
          "Test: " + testIdentifier.getDisplayName() + " id: " + testIdentifier.getUniqueId()
              + " parent id: " + testIdentifier.getParentId());
      this.summary.incrementTestsStarted();
    }
  }

  @Override
  public void executionFinished(TestIdentifier testIdentifier,
      TestExecutionResult testExecutionResult) {

    switch (testExecutionResult.getStatus()) {

      case SUCCESSFUL:
        successfulExecution(testIdentifier);
        break;

      case ABORTED:
        abortedExecution(testIdentifier);
        break;

      case FAILED:
        failedExecution(testIdentifier, testExecutionResult);
        break;

      default:
        throw new PreconditionViolationException(
            "Unsupported execution status:" + testExecutionResult.getStatus());
    }
  }

  private void failedExecution(TestIdentifier testIdentifier,
      TestExecutionResult testExecutionResult) {
    if (testIdentifier.isContainer()) {
      this.summary.incrementContainersFailed();
    }
    if (testIdentifier.isTest()) {
      this.summary.incrementTestsFailed();
    }
    testExecutionResult.getThrowable().ifPresent(
        throwable -> this.summary.addFailure(testIdentifier, throwable));
  }

  private void abortedExecution(TestIdentifier testIdentifier) {
    if (testIdentifier.isContainer()) {
      this.summary.incrementContainersAborted();
    }
    if (testIdentifier.isTest()) {
      this.summary.incrementTestsAborted();
    }
  }

  private void successfulExecution(TestIdentifier testIdentifier) {
    if (testIdentifier.isContainer()) {
      this.summary.incrementContainersSucceeded();
    }
    if (testIdentifier.isTest()) {
      this.summary.incrementTestsSucceeded();
    }
  }

}
